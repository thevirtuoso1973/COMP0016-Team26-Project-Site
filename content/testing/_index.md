---
title: "ðŸ§ª Testing"
description: "Testing strategies for NudgeMe."
layout: single
image: "images/system-design/gears.png"
date: 2021-03-09
draft: false
---

Although we experimented and used various ways to test our system, our main testing
strategy composed of user acceptance testing, to get feedback on the end user 
experience, and widget testing, to verify specific outcomes depending on
certain branches of logic.

Flutter supports three main testing strategies - unit, widget and integration testing -
and after evaluating all of them, widget testing was the most useful
for our app.

Flutter being a (mostly) declarative UI framework eliminates some classes of bugs
so we were able to focus on testing the parts that *do* have more complex logic.

# Unit Testing

Unit testing at it's simplest level tests whether a function has the expected
output, given some input. We use this style to test our cryptographic procedures.

We generated an example public/private key pair (using OpenSSL[^1]) and took the components:

``` dart
final publicExponent = BigInt.parse('65537');
final privateExponent = BigInt.parse('0x...',
    radix: 16);
final modulus = BigInt.parse('0x...',
    radix: 16);
final p = BigInt.parse('0x...',
    radix: 16);
final q = BigInt.parse('0x...',
    radix: 16);
const publicPEM = '-----BEGIN RSA PUBLIC KEY-----\n'
    'MIIBCgKCAQEAz6mfTm1Kwa9c4SKioJtRHtRSXKmnlFciMc1cGNKqVCaM00rW5Z5L'
    'Z3socDnx65ljsgiYhWXM1te6+x2HRX7qmS4SfgL/BHBYGzvnMbV7KTImuB03AeCA'
    'u4E5dYqFIhLPr7yROetuQujarPO7WKbFX3iYwj27Anr2FYm2xEtMDI1VkrpFPePm'
    'FS6w+s5EsSRAF3gDqrIDN66hGPPX08cLnaxVCn2IHAasjsrSvWXUaXvpTQD+8Zq0'
    'dac1u6UmqgGUqiwoZxjeliVHNWSEbHrd5UxgN8OgOeX7//KMHfbX21bbVyNrYDIB'
    'frPDdq+ifNYo9L2GgqtAE/GzkkzzILCvqQIDAQAB'
    '\n-----END RSA PUBLIC KEY-----';
```

_I have omitted the full strings since they are rather long._

Then we perform some short, quick tests to ensure it works as expected.
For example, we check if our encoding produces the same PEM string as the one 
generated by OpenSSL:
``` dart
test('encodePublicKeyInPem correctly encodes PKCS#1 public key to PEM', () {
  // setup public key
  final publicKey = RSAPublicKey(modulus, publicExponent);
  
  // execute function we are testing
  final encoded = encodePublicKeyInPem(publicKey);
  
  // verify expectations
  expect(encoded, publicPEM);
});
```

[^1]: https://en.wikibooks.org/wiki/Cryptography/Generate_a_keypair_using_OpenSSL

## Widget Testing

Since Flutter apps are primarily made up of widgets, Flutter provides a way to test
them in a virtual execution environment[^2]. We can then interact with the widget
with methods like `tester.drag` or `tester.tap`.

Here is an example of a test which found a bug:
``` dart
  testWidgets('Swipes through without exception', (WidgetTester tester) async {
    // draws up the `IntroScreen` onto the testing environment
    await tester.pumpWidget(wrapAppProvider(IntroScreen()));

    for (int i = 0; i < numberOfPages - 1; ++i) {
      // perform a swipe to the left, beginning from where the current image displayed
      // by the app is located
      await tester.drag(find.byType(Image), Offset(-500.0, 0.0));
      
      // wait for all the animations to complete
      await tester.pumpAndSettle();
    }
  });
```

`wrapAppProvider` is explained in the 'Mocking' section.

The bug that this found was a rendering bug with the UI. We initially ran the
program on our physical devices to test it, but since our devices have a large screen 
size, we didn't realize that our UI would not properly scale to fit smaller screens.
The virtual testing environment where these widget tests run have an intentionally
small screen size to pick up this class of bugs.

[^2]: Note that this 'virtual execution environment' is not quite an 'emulator', which
      is also why widget tests run much faster. Emulators are much slower.

## Mocking

For most widgets we are interested in testing, there is often some dependency that
we want to remove to ensure that we are only testing a small snippet of code.
We use the `mockito` package to mock dependencies.

In our code, the objects that we end up mocking are the database helper classes,
so we use a helper function to wrap a given widget around mocked databases:
``` dart
// wraps a [Widget] with [MaterialApp] and also provides mocked databases
Widget wrapAppProvider(Widget w, {UserWellbeingDB wbDB, FriendDB friendDB}) {
  if (wbDB == null) {
    wbDB = MockedWBDB();
  }
  if (friendDB == null) {
    friendDB = MockedFriendDB();
  }

  return MultiProvider(
    providers: [
      // provide the mocked databases for descendants:
      ChangeNotifierProvider.value(
        value: wbDB,
      ),
      ChangeNotifierProvider.value(
        value: friendDB,
      ),
    ],
    // we need to wrap it around a MaterialApp since the widgets we test are
    // smaller components that are normally already wrapped in a MaterialApp
    child: MaterialApp(
      home: w,
    ),
  );
}
```

We define mocked versions of a class like so:
``` dart
class _MockedDB extends Mock implements UserWellbeingDB {}
```
By default, `_MockedDB` is now stubbed, returning null for any methods called on it.
We can use `when`, `thenAnswer`, etc. on an instance of `_MockedDB` to specify how 
it should behave.

Here is one mock test that found a bug in the wellbeing check page:
``` dart
  testWidgets('Works when steps reset', (WidgetTester tester) async {
    // we also need to mock SharedPreferences:
    SharedPreferences.setMockInitialValues(
        {'postcode': 'N6', 'support_code': '12345', PREV_STEP_COUNT_KEY: 6666});

    // setup mocked wellbeing database:
    final mockedDB = _MockedDB();
    when(mockedDB.getLastNWeeks(3)).thenAnswer((_) async => <WellbeingItem>[]);

    // we don't need to use mockito or mocking to fake the step count stream,
    // we just create one:
    final fakeStepStream = Stream.fromIterable([0]);

    await tester.pumpWidget(
        wrapAppProvider(WellbeingCheck(fakeStepStream), wbDB: mockedDB));
    await tester.pumpAndSettle();

    // should be at score of 10 after dragging
    await tester.drag(find.byType(Slider), Offset(500.0, 0.0));
    await tester.pumpAndSettle();
    await withClock(
        // this should use the fake clock when requesting date
        Clock.fixed(DateTime(2021)),
        () async => await tester.tap(find.byType(ElevatedButton)));

    verify(mockedDB.getLastNWeeks(3));
    verify(mockedDB.insertWithData(
        date: "2021-01-01",
        postcode: 'N6',
        wellbeingScore: 10.0,
        // this part found the bug, the actual numSteps was negative:
        numSteps: 0, 
        supportCode: '12345'));
    final newPrev = await SharedPreferences.getInstance()
        .then((prefs) => prefs.getInt(PREV_STEP_COUNT_KEY));
    assert(newPrev == 0);
  });
```

_We also use the `clock` package to fake a time in the above test, since tests 
should definitely not be dependent on the time we run them at._

Verifying that `mockedDB.insertWithData` was called with the specified arguments
was the check that found the bug. (In particular, there was an arithmetic error
in the code that produced negative numbers when the step count was reset.)

## API Testing

## Continuous Integration

# Integration testing

# Performance Testing & Profiling

# User Acceptance Testing 

We carried out 2 types of user acceptance testing: alpha and beta testing. 

## Alpha testing 

Throughout development, we downloaded NudgeMe onto Naima and Vishnu's phones and asked them to report any issues or feedback.

Testers: 

* Naima (19 yrs, Computer Science student) 

* Vishnu (24 yrs, Software Engineer) 

Feedback from testers included: 

* During the development process, Naima informed us of small bugs associated with the step count and the graph. She also provided feedback on the various colour changes, for example with the wellbeing score circle on the home page and the change of navigation bar design.  

* Vishnu responded about the minute and second drop down buttons (in the notification time selector), saying that it was confusing. This was because the single digit numbers were not formatted with preceding 0â€™s (the minute options included 1, 2, 3 etc. rather than 01, 02, 03 etc.). He also expressed that it was not clear where users can scroll down and suggested adding a scroll bar to make this more obvious. Additionally, he asked that we add the option to change the sharing data permissions after the introduction screen, so we added this to the Settings page.


We sent several apks of NudgeMe to our project partner Joseph Connor and he provided constant feedback. This feedback was often in the form of small changes to the language we used in the application, particularly the introduction screen and the network page. In order to make this process simpler, we made figmas of these pages, which you can find here: [Introduction Screen Figma](https://www.figma.com/file/3pno0Tvp9M4BQ9K1p2zytV/NudgeMe-Intro-Screen), [Network Page Figma](https://www.figma.com/file/nZUDNKJuf0hcUDXRUVGJOD/Adding-friends). We used these to finalise the language before transferring the changes to the actual application in order to get on the same page and save time.

## Beta testing 

Once we finished NudgeMe, we downloaded the end product onto the phones of Vishnu, Anchal and Manni and asked them to provide feedback. This might be useful for future developments of NudgeMe.

Testers: 

* Vishnu (24 yrs, Software Engineer) 

* Anchal (30 yrs, Graphic Designer) 

* Manni (54 yrs, Pre-school teacher) 

Feedback from testers included:

* Vishnu found the home page confusing. He believes the wellbeing page should be considered the home page as it is the most useful and important page. Additionally, he thought that in the Support Code and Postcode sections of the Settings page, the current postcode/support code should be presented as hint text in the textboxes. He also thought a â€˜Send to Allâ€™ button on the network page could be a nice addition.  

* Anchal reported that she likes the bolded text on network page as it makes the information easier to read and the bump on the navigation bar that indicates which page is selected. She also loves the home screen as there is limited information so there is nothing to confuse her, and she thinks the emphasis on last week's score will encourage her to do better this week.

* Manni stated that NudgeMe will encourage her to do more exercise and that she likes the notification aspect as she thinks it will push her to move more. However, she also thought that the caption text is too small and she could not read support code text in the introduction screen about typing selfhelp. She found the text message containing the deep link confusing and was sightly reluctant to send it because she didnâ€™t recognise the link. In future iterations, the text could be enlarged and the deep link could be replaced with a bit.ly link to address these comments.

Feedback from Joseph (our project partner) included that on the step goal progress page, the man should be moving clockwise rather than anticlockwise (view the step goal progress [here](https://user-images.githubusercontent.com/55795994/108628127-f6197000-7450-11eb-8627-5a13b88993bd.mov)). We had previously considered making this change but had to prioritise some other changes first and in the end, did not have time.  

## Remote Error Reporting

We used [Sentry](https://sentry.io/for/flutter/) to remotely collect error 
logs and stack traces. Using sentry helped us during user acceptance testing
since we wouldn't have to rely on bug reports from (often non-technical) people.
Instead we were (usually) able to precisely identify the exact line of code
that caused the exception.

Sentry was especially useful when our project partner reported issues 
that we were not able to reproduce on our devices. There are slight differences
between Android versions and a functioning app on one version may be broken in
another. Therefore, even with a precise bug report, we would not have a clear
picture of the problem. This occurence was the reason that motivated us to
use Sentry in the first place, and allowed us to debug the issue.
